Proof of the Euclidean Algorithm

The Euclidean Algorithm is a method for computing the greatest common divisor (GCD) of two integers. It is based on the principle that the GCD of two numbers does not change if the larger number is replaced by its remainder when divided by the smaller number.

Step 1: Understanding the Algorithm

The Euclidean Algorithm states that for two integers ï¿¼ and ï¿¼ (where ï¿¼):

ï¿¼

where ï¿¼ is the remainder when ï¿¼ is divided by ï¿¼. This process is repeated until the remainder is 0, at which point the last nonzero remainder is the GCD.

Step 2: Proof of Correctness

Base Case: When ï¿¼ divides ï¿¼ exactly

If ï¿¼ is divisible by ï¿¼, then ï¿¼, which is correct since ï¿¼ is the largest number dividing both ï¿¼ and ï¿¼.

Inductive Step: The Recursive Property

We want to prove that:

ï¿¼

Step 2.1: Any Common Divisor of ï¿¼ and ï¿¼ Also Divides ï¿¼

	â€¢	Suppose ï¿¼ is a common divisor of both ï¿¼ and ï¿¼.
	â€¢	Since ï¿¼ (where ï¿¼), we can rewrite:
ï¿¼
	â€¢	Since ï¿¼ divides both ï¿¼ and ï¿¼, it must also divide ï¿¼.
	â€¢	Thus, ï¿¼ is a common divisor of ï¿¼ and ï¿¼.

Step 2.2: Any Common Divisor of ï¿¼ and ï¿¼ Also Divides ï¿¼

	â€¢	Suppose ï¿¼ is a common divisor of ï¿¼ and ï¿¼.
	â€¢	Since ï¿¼, any divisor of ï¿¼ and ï¿¼ must also divide ï¿¼.

Step 2.3: Conclusion

	â€¢	The set of common divisors of ï¿¼ and ï¿¼ are the same.
	â€¢	Therefore, the greatest common divisor must be the same:
ï¿¼

By repeating this process, we eventually reach a remainder of 0, at which point the last nonzero remainder is ï¿¼.

Step 3: Example

Find ï¿¼:
	1.	ï¿¼, remainder ï¿¼, so:
ï¿¼
	2.	ï¿¼, remainder ï¿¼, so:
ï¿¼
	3.	ï¿¼, remainder ï¿¼, so:
ï¿¼

Thus, ï¿¼.

Conclusion

The Euclidean Algorithm works because it continuously reduces the problem while preserving the set of common divisors. The process terminates when we reach a remainder of 0, ensuring that the last nonzero remainder is the greatest common divisor.

Let me know if you need further clarification! ğŸš€


Here is an implementation of the Euclidean Algorithm in Go to compute the greatest common divisor (GCD) of two integers:

Golang Code

package main

import (
	"fmt"
)

// gcd computes the Greatest Common Divisor using the Euclidean Algorithm
func gcd(a, b int) int {
	for b != 0 {
		a, b = b, a%b
	}
	return a
}

func main() {
	// Example usage
	a, b := 48, 18
	fmt.Printf("GCD of %d and %d is %d\n", a, b, gcd(a, b))
}

Explanation

	1.	The function gcd(a, b):
	â€¢	Uses a loop to replace ï¿¼ with ï¿¼ and ï¿¼ with ï¿¼.
	â€¢	Continues until ï¿¼ becomes zero.
	â€¢	The last nonzero ï¿¼ is returned as the GCD.
	2.	The main() function:
	â€¢	Calls gcd(48, 18), which computes the greatest common divisor.
	â€¢	Prints â€œGCD of 48 and 18 is 6â€.

Example Run

$ go run main.go
GCD of 48 and 18 is 6

Let me know if you need any modifications! ğŸš€

subtraction  5 + (-2)  : addition of additive inverse
division a / b = a * (1/b) : multiply of multiplicative inverse

additive inverse    multiplicative inverse
a + b = 0           a*b=1

congruent modulo (a%n) = (b%n)
modular addtive inverse (a+b)%n = 0
modular multiplicative inverse (a*b)%n = 1

a = q*b + r
r = a - q*b

GCD(a,b) = d
a = d*x
b = d*y
r = d*z

(a%n + b%n)%n = (a+b)%n
(a%n * b%n)%n = (a*b)%n

(a%n - b%n)

relatively prime

R - real number     Q = rational number     C = complex number     
Z = Interger  (-inf, inf)      N = natural number
Zn = Z%n = {0,1,2,3...,n-1}

% a*x + b*y = d
% a = d*m
% b = d*n

Xn = Xn-2 - qn*Xn-1

X1 = 1 - 3*0 = 1
y is modular mulriplicative inverse of b
b%a 
inverse of b (b*y)%a

2^n - 1     Mersenne Prime

toner(n) : the number of relative prime to n in the data set of Zn (Z%n)
if n is semi prime, n = p*q (p != 1 & (p,q) are prime); smallest one is 6, then toner(n) = (p-1)*(q-1)
if n  is a prime, then toner(n) = n-1

Fernel is a special case of Euler's therem

Miller-Rabin Primality Test in Go

The Miller-Rabin algorithm is a probabilistic primality test used to check if a number is prime. It is efficient and widely used in cryptographic applications.

1. Understanding the Miller-Rabin Algorithm

For a given odd integer ï¿¼ (to test for primality), we:
	1.	Write ï¿¼ as ï¿¼ where ï¿¼ is odd.
	2.	Choose a random base ï¿¼ such that ï¿¼.
	3.	Compute ï¿¼:
	â€¢	If ï¿¼ or ï¿¼, ï¿¼ may be prime.
	4.	Repeat squaring ï¿¼ times to check if any power is ï¿¼ modulo ï¿¼.
	5.	If ï¿¼ passes multiple rounds of testing, it is probably prime.

2. Go Implementation

Here is the Go implementation of the Miller-Rabin Primality Test:

package main

import (
	"fmt"
	"math/big"
	"math/rand"
	"time"
)

// isPrime checks if n is a prime using Miller-Rabin test with k iterations
func isPrime(n int64, k int) bool {
	// Handle small cases
	if n < 2 {
		return false
	}
	if n == 2 || n == 3 {
		return true
	}
	if n%2 == 0 {
		return false
	}

	// Write n-1 as 2^s * d
	d := n - 1
	s := 0
	for d%2 == 0 {
		d /= 2
		s++
	}

	// Seed random number generator
	rand.Seed(time.Now().UnixNano())

	// Perform k rounds of Miller-Rabin test
	for i := 0; i < k; i++ {
		a := rand.Int63n(n-3) + 2 // Random number in range [2, n-2]
		if !millerRabinTest(n, d, s, a) {
			return false // Composite
		}
	}
	return true // Probably prime
}

// millerRabinTest performs a single iteration of the Miller-Rabin test
func millerRabinTest(n, d int64, s int, a int64) bool {
	// Compute a^d % n using big.Int to handle large numbers
	ad := new(big.Int).Exp(big.NewInt(a), big.NewInt(d), big.NewInt(n))
	if ad.Int64() == 1 || ad.Int64() == n-1 {
		return true
	}

	// Square multiple times
	for i := 0; i < s-1; i++ {
		ad.Exp(ad, big.NewInt(2), big.NewInt(n))
		if ad.Int64() == n-1 {
			return true
		}
	}

	return false
}

// Main function to test the Miller-Rabin algorithm
func main() {
	n := int64(101) // Number to test
	k := 5          // Number of iterations
	if isPrime(n, k) {
		fmt.Printf("%d is probably prime\n", n)
	} else {
		fmt.Printf("%d is composite\n", n)
	}
}

3. Explanation

	1.	isPrime(n, k):
	â€¢	Handles small numbers.
	â€¢	Writes ï¿¼ as ï¿¼.
	â€¢	Runs the Miller-Rabin test ï¿¼ times with random bases.
	2.	millerRabinTest(n, d, s, a):
	â€¢	Computes ï¿¼ using big.Int to prevent overflow.
	â€¢	Checks if ï¿¼ or ï¿¼ modulo ï¿¼.
	â€¢	Squares repeatedly up to ï¿¼ times.
	3.	Randomness & Security:
	â€¢	The test is probabilistic, so multiple iterations increase confidence.
	â€¢	Setting ï¿¼ or ï¿¼ gives high accuracy.

4. Example Output

101 is probably prime

If you run it for composite numbers, it will correctly identify them.

5. Performance and Use Cases

	â€¢	Time Complexity: ï¿¼ (Fast for large numbers)
	â€¢	Used in Cryptography (RSA, Diffie-Hellman, etc.)
	â€¢	Can be made deterministic by using specific bases (e.g., for 32-bit numbers).

Let me know if you need any modifications! ğŸš€

Extended Euclidean Algorithm Explanation

The Extended Euclidean Algorithm is an extension of the Euclidean Algorithm that finds not only the greatest common divisor (GCD) of two integers ï¿¼ and ï¿¼ but also integers ï¿¼ and ï¿¼ such that:

ï¿¼


Q is quotient
Xn = X(n-2) - Q(n) * X(n-1)
Yn = Y(n-2) - Q(n) * Y(n-1)

## **Finding the Multiplicative Inverse Using the Extended Euclidean Algorithm**
The **multiplicative inverse** of a number **a modulo m** is an integer **x** such that:

\[
a \cdot x \equiv 1 \mod m
\]

This means that **x** is the number that, when multiplied by **a**, gives **1 mod m**. The multiplicative inverse **exists only if a and m are coprime**, meaning:

\[
\gcd(a, m) = 1
\]

---

## **Using the Extended Euclidean Algorithm**
From the **Extended Euclidean Algorithm**, we find **x** and **y** such that:

\[
ax + my = \gcd(a, m)
\]

If **gcd(a, m) = 1**, then the equation simplifies to:

\[
ax + my = 1
\]

Taking **mod m** on both sides:

\[
ax \equiv 1 \mod m
\]

Thus, **x** is the modular inverse of **a modulo m**.

If **gcd(a, m) â‰  1**, the modular inverse **does not exist**.

---

## **Golang Implementation for Modular Inverse**
```go
package main

import (
	"fmt"
)

// ExtendedEuclidean computes the GCD and finds x, y such that ax + by = gcd(a, b)
func ExtendedEuclidean(a, b int) (int, int, int) {
	if b == 0 {
		return a, 1, 0
	}

	gcd, x1, y1 := ExtendedEuclidean(b, a%b)
	x := y1
	y := x1 - (a/b)*y1

	return gcd, x, y
}

// ModInverse finds the modular inverse of a mod m using Extended Euclidean Algorithm
func ModInverse(a, m int) (int, error) {
	gcd, x, _ := ExtendedEuclidean(a, m)

	// Inverse exists only if gcd(a, m) == 1
	if gcd != 1 {
		return 0, fmt.Errorf("modular inverse does not exist for %d mod %d", a, m)
	}

	// x might be negative, so make it positive by adding m
	return (x%m + m) % m, nil
}

func main() {
	a, m := 3, 7 // Example: Find 3â»Â¹ mod 7
	inverse, err := ModInverse(a, m)
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Printf("Modular inverse of %d mod %d is %d\n", a, m, inverse)
	}
}
```

---

## **ğŸ”¹ Example Output**
For **a = 3** and **m = 7**, the output is:
```
Modular inverse of 3 mod 7 is 5
```
ğŸ”¹ **Verification**:
\[
3 \times 5 \equiv 1 \mod 7
\]
\[
15 \mod 7 = 1
\]
âœ” Correct!

---

## **ğŸ”¹ How It Works**
1. **Compute gcd(a, m) using Extended Euclidean Algorithm**.
2. **If gcd(a, m) â‰  1**, no modular inverse exists.
3. **Extract x from the equation `ax + my = 1`**.
4. **Ensure x is positive** by using `(x % m + m) % m`.

---

## **ğŸ”¹ Time Complexity**
- The **Extended Euclidean Algorithm** runs in **O(log m)**, making this approach **efficient**.

---

## **ğŸ”¹ Applications**
- **Cryptography** (RSA, ECC)
- **Solving modular equations**
- **Chinese Remainder Theorem**

Would you like an example for a large prime modulus (e.g., used in cryptography)? ğŸš€

## **ğŸ”¹ Explanation of the Two Key Steps in Finding the Modular Inverse**

### **1ï¸âƒ£ Extracting `x` from the equation \( ax + my = 1 \)**

From the **Extended Euclidean Algorithm**, we obtain three values:  
- **gcd(a, m)**
- **x** (a coefficient)
- **y** (another coefficient)

We get these values by recursively solving:

\[
\gcd(a, m) = ax + my
\]

If **gcd(a, m) = 1**, the equation simplifies to:

\[
ax + my = 1
\]

Since we are looking for **the modular inverse**, we focus on **x**, because:

\[
ax \equiv 1 \mod m
\]

This means **x is the modular inverse of `a` modulo `m`**.

However, `x` obtained from the algorithm may be **negative**, which is not suitable for modular arithmetic. That leads to the next step.

---

### **2ï¸âƒ£ Ensuring `x` is Positive using \( (x \mod m + m) \mod m \)**

If `x` is **negative**, we cannot directly use it as the modular inverse because modular arithmetic deals with **non-negative residues**.  
To convert `x` into a positive number within the range `[0, m-1]`, we use:

\[
x' = (x \mod m + m) \mod m
\]

#### **Why does this formula work?**
- **Modulo operation:** `x % m` gives the remainder when `x` is divided by `m`.  
  - If `x` is already positive, `x % m` remains unchanged.  
  - If `x` is negative, `x % m` returns a negative remainder.
- **Adding `m` to handle negatives:**  
  - If `x % m` is negative, adding `m` makes it positive.
  - If `x % m` is already positive, adding `m` keeps it within the correct range.
- **Final modulo ensures it stays within `[0, m-1]`.**

---

### **ğŸ”¹ Example: Handling a Negative `x`**
Letâ€™s say we are computing \( 3^{-1} \mod 7 \) using the Extended Euclidean Algorithm.

From the algorithm, we get:

\[
x = -2
\]

But the modular inverse should be **a positive number** in the range `[0, 6]`.  
Using the formula:

\[
(-2 \mod 7 + 7) \mod 7
\]

Step-by-step:
1. \( -2 \mod 7 = -2 \) (since `-2` is already less than `7`, it remains `-2`)
2. Add `7`: \( -2 + 7 = 5 \)
3. Final modulo: \( 5 \mod 7 = 5 \)

So, the modular inverse is **5**, meaning:

\[
3 \times 5 \equiv 1 \mod 7
\]

âœ” Correct!

---

### **ğŸ”¹ Summary**
âœ… **Extract `x` from the equation** \( ax + my = 1 \) using the Extended Euclidean Algorithm.  
âœ… **Ensure `x` is positive** using \( (x \mod m + m) \mod m \) to get a **valid modular inverse**.

Would you like an example with a large prime modulus (as in cryptography)? ğŸš€

### **ğŸ”¹ Using Fermatâ€™s Theorem to Compute Modular Exponentiation**
Fermatâ€™s Little Theorem states that for any integer \( a \) that is **not divisible** by a prime number \( p \):

\[
a^{p-1} \equiv 1 \mod p
\]

This theorem helps simplify exponentiation problems, especially when computing **modular inverses**.

---

### **ğŸ”¹ Example: Compute \( 7^{100} \mod 13 \)**

We want to calculate:

\[
7^{100} \mod 13
\]

Since \( 13 \) is a prime number, Fermatâ€™s theorem tells us:

\[
7^{12} \equiv 1 \mod 13
\]

#### **ğŸ”¹ Step 1: Reduce the Exponent Using Fermatâ€™s Theorem**
Since \( 100 \) is large, we express it in terms of \( 12 \):

\[
100 = 12 \times 8 + 4
\]

So we rewrite the exponent:

\[
7^{100} = (7^{12})^8 \times 7^4
\]

Using Fermatâ€™s theorem:

\[
(7^{12})^8 \equiv 1^8 \equiv 1 \mod 13
\]

Thus:

\[
7^{100} \equiv 7^4 \mod 13
\]

---

#### **ğŸ”¹ Step 2: Compute \( 7^4 \mod 13 \)**
We break it down:

\[
7^2 = 49
\]

\[
49 \mod 13 = 49 - 3 \times 13 = 49 - 39 = 10
\]

So,

\[
7^2 \equiv 10 \mod 13
\]

Now,

\[
7^4 = (7^2)^2 = 10^2 = 100
\]

\[
100 \mod 13 = 100 - 7 \times 13 = 100 - 91 = 9
\]

Thus,

\[
7^{100} \equiv 9 \mod 13
\]

---

### **ğŸ”¹ Final Answer**
\[
\boxed{9}
\]

This method drastically simplifies large exponentiation problems using Fermatâ€™s theorem! ğŸš€