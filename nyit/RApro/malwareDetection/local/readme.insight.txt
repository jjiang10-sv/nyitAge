
### Data File Structure

The data file stores three types of information:
- **PE header parsing results**
- **Disassembly instructions**
- **Control flow graphs (CFG)**

The raw data is stored in JSON format, typically with a `.insight` suffix. 
Files ending with `.gz` are compressed using gzip and can be viewed using the `zcat` command in Linux. 
For `.insight` files, use `cat` or any text viewer.

Since the data is in JSON format, it can be parsed using the `jq` utility, as demonstrated below:

```bash
$ zcat 00/000025c20f564ea5e438f78d01c44f79a001aa956327d3d0d78e74acb90c6775.gz | jq 'keys'
[
  "bloced_instrs",
  "cfg",
  "cpu",
  "entropies",
  "func_basics",
  "headers",
  "imports",
  "instrs",
  "notes",
  "time_consumed",
  "ts"
]
```

For analysis, you only need to focus on the following keys: **bloced_instrs**, **cfg**, and **headers**.

---

### 1. `bloced_instrs`: Disassembly Instructions

The `bloced_instrs` section contains the disassembled instructions, structured as a JSON dictionary 
where each function is stored with its starting address as the key. 

#### Example Structure:
```json
{
  "func1_addr": { "func1 instructions" },
  "func2_addr": { "func2 instructions" },
  "func3_addr": { "func3 instructions" },
  ...
}
```

#### Viewing Functions in `bloced_instrs`:
To list all function addresses:
```bash
$ zcat 00/000025c20f564ea5e438f78d01c44f79a001aa956327d3d0d78e74acb90c6775.gz | jq .bloced_instrs | jq 'keys' | more
```
Example output:
```json
[
  "4198400",
  "4198592",
  "4199120",
  "4200048",
  "4203872",
  "4207728",
  "4207808",
  "4217872",
  "4218032",
  "4218592",
  ...
]
```

#### Viewing Disassembled Instructions:
```bash
$ zcat 00/000025c20f564ea5e438f78d01c44f79a001aa956327d3d0d78e74acb90c6775.gz | jq .bloced_instrs | more
```

Example output:
```json
{
  "4198400": {
    "4198400": [
      "push-ebp",
      "mov-ebp-esp",
      "push-N",
      "push-loc",
      "push-loc",
      "mov-eax-loc",
      "push-eax",
      "sub-esp-N",
      "push-ebx",
      "push-esi",
      "push-edi",
      "mov-eax-loc",
      "xor-[ebp+S]-eax",
      "xor-eax-ebp",
      "push-eax",
      "lea-eax-[ebp+S]",
      "mov-loc-eax",
      "mov-[ebp+S]-esp",
      "mov-[ebp+S]-N",
      "xor-edi-edi"
    ],
    "4198460": [
      "mov-[ebp+S]-edi",
      "push-edi",
      "call-M",
      "mov-ebx-eax",
      "cmp-ebx-edi",
      "jz-M"
    ],
    ...
  }
}
```

Each function consists of multiple **basic blocks**, and each block contains 
a series of disassembled instructions.

---

### 2. `cfg`: Control Flow Graph

The `cfg` section contains the control flow graph (CFG) structure, represented as a JSON dictionary. 
Each function is mapped to a list of basic blocks, where each block is represented as a dictionary with:
- **start**: Start address
- **end**: End address
- **successors**: List of next blocks in the control flow

#### Viewing CFG:
```bash
$ zcat 00/000025c20f564ea5e438f78d01c44f79a001aa956327d3d0d78e74acb90c6775.gz | jq .cfg | more
```

#### Example Output:
```json
{
  "4198400": [
    {
      "start": 4198400,
      "end": 4198460,
      "successors": [4198460]
    },
    {
      "start": 4198460,
      "end": 4198476,
      "successors": [4198563, 4198476]
    },
    {
      "start": 4198476,
      "end": 4198489,
      "successors": [4198563, 4198489]
    },
    {
      "start": 4198489,
      "end": 4198500,
      "successors": [4198563, 4198500]
    },
    {
      "start": 4198500,
      "end": 4198525,
      "successors": [4198544, 4198525]
    }
  ],
  ...
}
```
Each basic block represents a **vertex** in the CFG, while the `successors` field defines 
the **edges** connecting blocks.

---

### 3. `headers`: PE Header Information

The `headers` section contains parsed data from the PE file header, similar to what tools like **pebear** 
and **PEStudio** display.

#### Viewing PE Header:
```bash
$ zcat 00/000025c20f564ea5e438f78d01c44f79a001aa956327d3d0d78e74acb90c6775.gz | jq .headers | more
```

#### Example Output:
```json
{
  "DOS_Header": {
    "e_magic": "0x5a4d",
    "e_cblp": "0x90",
    "e_cp": "0x3",
    "e_crlc": "0x0",
    "e_cparhdr": "0x4",
    "e_minalloc": "0x0",
    "e_maxalloc": "0xffff",
    "e_ss": "0x0",
    "e_sp": "0xb8",
    "e_csum": "0x0",
    "e_ip": "0x0",
    "e_cs": "0x0",
    "e_lfanew": "0xf0"
  },
  "NT_Header": {
    "Machine": "0x14c",
    "NumberOfSections": 5,
    "TimeDateStamp": "0x4653df87",
    "PointerToSymbolTable": "0x0",
    "NumberOfSymbols": 0,
    "SizeOfOptionalHeader": 224,
    "Characteristics": "0x102"
  },
  "Optional_Header": {
    "Magic": "0x10b",
    "EntryPointAddress": "0x1213e",
    "ImageBase": "0x400000",
    "SectionAlignment": "0x1000",
    "FileAlignment": "0x200",
    "Subsystem": 2,
    "DllCharacteristics": "0x8140",
    "SizeOfImage": "0x7a000",
    "SizeOfHeaders": "0x400",
    "SizeOfStackReserve": "0x100000",
    "SizeOfStackCommit": "0x1000"
  }
}
```

---

### Summary:
- `bloced_instrs`: Stores disassembled instructions, grouped by functions and basic blocks.
- `cfg`: Represents control flow graphs, mapping functions to basic blocks with successor information.
- `headers`: Contains PE file header details.

These features are stored in JSON format, and `jq` can be used to extract specific parts efficiently.

Let me know if you need further refinements! ðŸš€