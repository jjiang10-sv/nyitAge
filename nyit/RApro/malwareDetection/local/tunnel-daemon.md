# Making VS Code Tunnel a Daemon Process

## Method 1: Using systemd (Linux - Recommended)

Create a systemd service file to run the tunnel as a daemon:

### 1. Create the service file

```bash
sudo nano /etc/systemd/system/vscode-tunnel.service
```

### 2. Add the following content:

```ini
[Unit]
Description=VS Code Tunnel
After=network.target

[Service]
Type=simple
User=stu
WorkingDirectory=/home/stu
ExecStart=/home/stu/.vscode-cli/code tunnel --name nyit_mal --accept-server-license-terms
Restart=always
RestartSec=10
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
```

### 3. Enable and start the service:

```bash
sudo systemctl daemon-reload
sudo systemctl enable vscode-tunnel
sudo systemctl start vscode-tunnel
```

### 4. Check status:

```bash
sudo systemctl status vscode-tunnel
```

## Method 2: Using screen/tmux (Quick Solution)

### Using screen:

```bash
# Install screen if not available
sudo apt-get install screen

# Start a detached screen session
screen -dmS vscode-tunnel

# Attach to the session and run the tunnel
screen -r vscode-tunnel
# Then run: .vscode-cli/code tunnel --name nyit_mal --accept-server-license-terms

# Detach with Ctrl+A, D
```

### Using tmux:

```bash
# Install tmux if not available
sudo apt-get install tmux

# Start a detached tmux session
tmux new-session -d -s vscode-tunnel

# Run the tunnel in the session
tmux send-keys -t vscode-tunnel '.vscode-cli/code tunnel --name nyit_mal --accept-server-license-terms' Enter

# List sessions
tmux list-sessions

# Attach to session
tmux attach-session -t vscode-tunnel
```

## Method 3: Using nohup (Simple Background Process)

```bash
# Run with nohup to ignore hangup signals
nohup .vscode-cli/code tunnel --name nyit_mal --accept-server-license-terms > tunnel.log 2>&1 &

# Check if running
ps aux | grep "code tunnel"

# Get the process ID
pgrep -f "code tunnel"
```

## Method 4: Creating a Custom Script with Auto-restart

Create a wrapper script that automatically restarts the tunnel if it stops:

```bash
#!/bin/bash
# tunnel-keeper.sh

TUNNEL_NAME="nyit_mal"
LOG_FILE="/home/stu/tunnel.log"

while true; do
    echo "$(date): Starting VS Code tunnel..." >> "$LOG_FILE"

    # Run the tunnel
    .vscode-cli/code tunnel --name "$TUNNEL_NAME" --accept-server-license-terms

    # If we reach here, the tunnel stopped
    echo "$(date): Tunnel stopped. Restarting in 10 seconds..." >> "$LOG_FILE"
    sleep 10
done
```

Make it executable and run:

```bash
chmod +x tunnel-keeper.sh
nohup ./tunnel-keeper.sh &
```

### Proper Daemon Implementation

For a true daemon process with proper process management, use the `tunnel-daemon.sh` script:

```bash
# Make the daemon script executable
chmod +x tunnel-daemon.sh

# Start the daemon
./tunnel-daemon.sh start

# Check status
./tunnel-daemon.sh status

# View logs
./tunnel-daemon.sh logs

# Follow logs in real-time
./tunnel-daemon.sh logs -f

# Stop the daemon
./tunnel-daemon.sh stop

# Restart the daemon
./tunnel-daemon.sh restart

# Install as system service (optional, requires root)
sudo ./tunnel-daemon.sh install
```

This daemon implementation provides:

- **Proper process detachment** from terminal
- **PID file management** for process tracking
- **Automatic restart** when tunnel fails
- **Logging** to dedicated log file
- **Process management** (start/stop/restart/status)
- **System service integration** (optional)

## Method 5: Using Docker (Advanced)

Create a Dockerfile:

```dockerfile
FROM ubuntu:22.04

RUN apt-get update && apt-get install -y curl

# Download and install VS Code CLI
RUN curl -Lk 'https://code.visualstudio.com/sha/download?build=stable&os=cli-alpine-x64' --output vscode_cli.tar.gz
RUN tar -xf vscode_cli.tar.gz

# Copy the extracted binary to a location in PATH
RUN mv code /usr/local/bin/

WORKDIR /app
CMD ["code", "tunnel", "--name", "nyit_mal", "--accept-server-license-terms"]
```

Build and run:

```bash
docker build -t vscode-tunnel .
docker run -d --name vscode-tunnel-daemon --restart unless-stopped vscode-tunnel
```

## Monitoring and Management Commands

### For systemd service:

```bash
# Start/stop/restart
sudo systemctl start vscode-tunnel
sudo systemctl stop vscode-tunnel
sudo systemctl restart vscode-tunnel

# View logs
journalctl -u vscode-tunnel -f

# Check status
sudo systemctl status vscode-tunnel
```

### For process-based methods:

```bash
# Find the process
ps aux | grep "code tunnel"
pgrep -f "code tunnel"

# Kill the process
pkill -f "code tunnel"

# Check if port is in use
netstat -tlnp | grep :8000  # or whatever port the tunnel uses
```

## Recommended Approach

**For production/server environments**: Use **Method 1 (systemd)** as it provides:

- Automatic startup on boot
- Automatic restart on failure
- Proper logging
- System integration
- Easy management

**For development/temporary use**: Use **Method 2 (screen/tmux)** for quick setup and easy access.

## Security Considerations

1. **Firewall**: Ensure only necessary ports are open
2. **User permissions**: Run with limited user privileges
3. **Authentication**: Use GitHub authentication as you're already doing
4. **Network**: Consider using VPN for additional security
5. **Monitoring**: Set up log monitoring for suspicious activities

## Troubleshooting

- If the tunnel keeps disconnecting, check network stability
- Monitor system resources (CPU, memory, disk space)
- Check VS Code server logs for errors
- Ensure the machine has a stable internet connection
- Verify firewall settings don't block the tunnel
